#![allow(dead_code)]

mod utils;

use nist_pqc_seeded_rng::{NistPqcAes256CtrRng, RngCore, SeedableRng};

use crate::{
    constants::{
        params::{PARAM_SALT_SIZE, PARAM_SEED_SIZE},
        types::{Salt, Seed},
    },
    keygen::{PublicKey, SecretKey},
};

struct NistEntropy {
    keygen_seed: Seed,
    sign_salt: Salt,
    sign_seed: Seed,
}

impl NistEntropy {
    fn new(seed: nist_pqc_seeded_rng::Seed) -> Self {
        // Initiate NIST rng
        let mut rng = NistPqcAes256CtrRng::from_seed(seed);
        let mut keygen_seed: Seed = [0u8; PARAM_SEED_SIZE];

        // First create master seed
        rng.fill_bytes(&mut keygen_seed);

        // Next create salt
        let mut sign_salt: Salt = [0u8; PARAM_SALT_SIZE];
        rng.fill_bytes(&mut sign_salt);

        // Finally create signing seed
        let mut sign_seed: Seed = [0u8; PARAM_SEED_SIZE];
        rng.fill_bytes(&mut sign_seed);

        NistEntropy {
            keygen_seed,
            sign_salt,
            sign_seed,
        }
    }
}

struct TestVectorResponse {
    count: usize,
    nist_entropy: NistEntropy,
    mlen: usize,
    msg: Vec<u8>,
    pk: PublicKey,
    sk: SecretKey,
    sm: Vec<u8>,
    smlen: usize,
}

/// Convert a hex string to a NIST [`nist_pqc_seeded_rng::Seed`]
fn seed_from_hex(hex: &str) -> nist_pqc_seeded_rng::Seed {
    hex::decode(hex).unwrap()[..48].try_into().unwrap()
}

fn get_value_from_line(line: &str) -> &str {
    line.split(" = ").collect::<Vec<&str>>()[1]
}

fn get_response_file() -> &'static str {
    if cfg!(feature = "category_three") {
        include_str!("./vectors/cat3_gf256/PQCsignKAT.rsp")
    } else if cfg!(feature = "category_five") {
        include_str!("./vectors/cat5_gf256/PQCsignKAT.rsp")
    } else {
        include_str!("./vectors/cat1_gf256/PQCsignKAT.rsp")
    }
}

/// Read the files generated by the specification library, PQCsignKAT_404.req and PQCsignKAT_404.rsp
fn read_response_test_vectors(n: usize) -> Vec<TestVectorResponse> {
    let rsp_file = get_response_file();
    let mut rsp_lines = rsp_file.lines();
    rsp_lines.next(); // Skip the first line -> # sdith_threshold_cat1_gf256

    let mut test_vectors = Vec::new();
    let mut read_vectors = 0;

    while read_vectors < n {
        rsp_lines.next(); // Skip empty line
        let count: usize = get_value_from_line(rsp_lines.next().unwrap())
            .parse()
            .unwrap();
        let seed = seed_from_hex(&get_value_from_line(rsp_lines.next().unwrap()));
        let mlen: usize = get_value_from_line(rsp_lines.next().unwrap())
            .parse()
            .unwrap();

        let msg = hex::decode(get_value_from_line(rsp_lines.next().unwrap())).unwrap();
        let pk = PublicKey::parse_from_hex(&get_value_from_line(rsp_lines.next().unwrap()));
        let sk = SecretKey::parse_from_hex(&get_value_from_line(rsp_lines.next().unwrap()));
        let smlen: usize = get_value_from_line(rsp_lines.next().unwrap())
            .parse()
            .unwrap();
        let sm = hex::decode(get_value_from_line(rsp_lines.next().unwrap())).unwrap();

        test_vectors.push(TestVectorResponse {
            count,
            nist_entropy: NistEntropy::new(seed),
            mlen,
            msg,
            pk,
            sk,
            sm,
            smlen,
        });
        read_vectors += 1;
    }

    test_vectors
}

#[cfg(test)]
mod kat_tests {
    use super::*;

    use crate::{signature::Signature, utils::marshalling::Marshalling as _};

    fn signature_eq(a: &Signature, b: &Signature) -> bool {
        assert_eq!(
            a.broadcast_plain, b.broadcast_plain,
            "Broadcast plain mismatch"
        );
        assert_eq!(
            a.broadcast_shares, b.broadcast_shares,
            "Broadcast shares mismatch"
        );
        assert_eq!(a.message, b.message, "Message mismatch");
        assert_eq!(a.salt, b.salt, "Salt mismatch");
        assert_eq!(a.h1, b.h1, "Hash 1 mismatch");
        assert_eq!(
            a.solution_share, b.solution_share,
            "Solution shares mismatch"
        );
        assert_eq!(a.auth, b.auth, "Auth paths mismatch");
        assert_eq!(
            a.view_opening_challenges, b.view_opening_challenges,
            "View opening challenges mismatch"
        );

        return true;
    }

    #[test]
    fn test_read_test_vectors() {
        let v = read_response_test_vectors(2);
        assert_eq!(v.len(), 2);
        assert!(v[0].count == 0);
        assert!(v[0].mlen == 33);
        assert_eq!(
            hex::encode(&v[0].msg).to_uppercase(),
            "D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8"
        );
    }

    // #[test]
    // fn test_signing_and_verifying_with_kat_entropy() {
    //     let v = read_response_test_vectors(100);
    //     for tv in v {
    //         let (pk, sk) = keygen(tv.nist_entropy.keygen_seed);
    //         let signature = Signature::sign_message(
    //             (tv.nist_entropy.sign_seed, tv.nist_entropy.sign_salt),
    //             &sk,
    //             &tv.msg,
    //         );
    //         assert!(signature.is_ok());
    //         let signature = signature.unwrap();
    //
    //         let verification = Signature::verify_signature(&pk, &signature.serialise());
    //         assert!(verification.is_ok());
    //     }
    // }

    #[test]
    fn test_signature_align() {
        let v = read_response_test_vectors(100);
        for tv in v {
            let sk = tv.sk;
            let kat_signature = Signature::parse(&tv.sm).unwrap();

            let signature = Signature::sign_message(
                (tv.nist_entropy.sign_seed, tv.nist_entropy.sign_salt),
                &sk,
                &tv.msg,
            );

            assert!(signature.is_ok());
            let signature = signature.unwrap();

            assert!(signature_eq(&signature, &kat_signature));
        }
    }

    #[test]
    fn test_verify_align() {
        let v = read_response_test_vectors(100);
        for tv in v {
            assert!(Signature::verify_signature(&tv.pk, &tv.sm).is_ok());
        }
    }
}
