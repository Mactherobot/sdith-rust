// Galois field 256 F_256 operations

use std::{
    fmt::Debug,
    num::Wrapping,
    ops::{Add, Div, Mul, Sub},
};

use num_traits::CheckedDiv;

const MODULUS: u8 = 0x1B; // The primitive polynomial x^4 + x^3 + x + 1 (0b0001_1011)
const _GENERATOR: u8 = 0x03; // The generator polynomial x + 1 ({03}) of the multiplicative group of GF(2^8)
const ORDER: u8 = 0xff; // The order of the multiplicative group of GF(2^8)

// Precomputed tables for fast multiplication and division in GF(2^8) using the generator polynomial x + 1 ({03})

/// Table lookup for g^i where g = 0x03
const POWER_TABLE_0X03: [u8; 256] = [
    0x01, 0x03, 0x05, 0x0f, 0x11, 0x33, 0x55, 0xff, 0x1a, 0x2e, 0x72, 0x96, 0xa1, 0xf8, 0x13, 0x35,
    0x5f, 0xe1, 0x38, 0x48, 0xd8, 0x73, 0x95, 0xa4, 0xf7, 0x02, 0x06, 0x0a, 0x1e, 0x22, 0x66, 0xaa,
    0xe5, 0x34, 0x5c, 0xe4, 0x37, 0x59, 0xeb, 0x26, 0x6a, 0xbe, 0xd9, 0x70, 0x90, 0xab, 0xe6, 0x31,
    0x53, 0xf5, 0x04, 0x0c, 0x14, 0x3c, 0x44, 0xcc, 0x4f, 0xd1, 0x68, 0xb8, 0xd3, 0x6e, 0xb2, 0xcd,
    0x4c, 0xd4, 0x67, 0xa9, 0xe0, 0x3b, 0x4d, 0xd7, 0x62, 0xa6, 0xf1, 0x08, 0x18, 0x28, 0x78, 0x88,
    0x83, 0x9e, 0xb9, 0xd0, 0x6b, 0xbd, 0xdc, 0x7f, 0x81, 0x98, 0xb3, 0xce, 0x49, 0xdb, 0x76, 0x9a,
    0xb5, 0xc4, 0x57, 0xf9, 0x10, 0x30, 0x50, 0xf0, 0x0b, 0x1d, 0x27, 0x69, 0xbb, 0xd6, 0x61, 0xa3,
    0xfe, 0x19, 0x2b, 0x7d, 0x87, 0x92, 0xad, 0xec, 0x2f, 0x71, 0x93, 0xae, 0xe9, 0x20, 0x60, 0xa0,
    0xfb, 0x16, 0x3a, 0x4e, 0xd2, 0x6d, 0xb7, 0xc2, 0x5d, 0xe7, 0x32, 0x56, 0xfa, 0x15, 0x3f, 0x41,
    0xc3, 0x5e, 0xe2, 0x3d, 0x47, 0xc9, 0x40, 0xc0, 0x5b, 0xed, 0x2c, 0x74, 0x9c, 0xbf, 0xda, 0x75,
    0x9f, 0xba, 0xd5, 0x64, 0xac, 0xef, 0x2a, 0x7e, 0x82, 0x9d, 0xbc, 0xdf, 0x7a, 0x8e, 0x89, 0x80,
    0x9b, 0xb6, 0xc1, 0x58, 0xe8, 0x23, 0x65, 0xaf, 0xea, 0x25, 0x6f, 0xb1, 0xc8, 0x43, 0xc5, 0x54,
    0xfc, 0x1f, 0x21, 0x63, 0xa5, 0xf4, 0x07, 0x09, 0x1b, 0x2d, 0x77, 0x99, 0xb0, 0xcb, 0x46, 0xca,
    0x45, 0xcf, 0x4a, 0xde, 0x79, 0x8b, 0x86, 0x91, 0xa8, 0xe3, 0x3e, 0x42, 0xc6, 0x51, 0xf3, 0x0e,
    0x12, 0x36, 0x5a, 0xee, 0x29, 0x7b, 0x8d, 0x8c, 0x8f, 0x8a, 0x85, 0x94, 0xa7, 0xf2, 0x0d, 0x17,
    0x39, 0x4b, 0xdd, 0x7c, 0x84, 0x97, 0xa2, 0xfd, 0x1c, 0x24, 0x6c, 0xb4, 0xc7, 0x52, 0xf6, 0x01,
];

fn power_lookup(a: u8) -> u8 {
    POWER_TABLE_0X03[a as usize]
}

/// Table lookup for log_g(a) where g = 0x03. Note that log_g(0) is undefined.
const LOG_TABLE_0X03: [u8; 255] = [
    0x00, 0x19, 0x01, 0x32, 0x02, 0x1a, 0xc6, 0x4b, 0xc7, 0x1b, 0x68, 0x33, 0xee, 0xdf, 0x03, 0x64,
    0x04, 0xe0, 0x0e, 0x34, 0x8d, 0x81, 0xef, 0x4c, 0x71, 0x08, 0xc8, 0xf8, 0x69, 0x1c, 0xc1, 0x7d,
    0xc2, 0x1d, 0xb5, 0xf9, 0xb9, 0x27, 0x6a, 0x4d, 0xe4, 0xa6, 0x72, 0x9a, 0xc9, 0x09, 0x78, 0x65,
    0x2f, 0x8a, 0x05, 0x21, 0x0f, 0xe1, 0x24, 0x12, 0xf0, 0x82, 0x45, 0x35, 0x93, 0xda, 0x8e, 0x96,
    0x8f, 0xdb, 0xbd, 0x36, 0xd0, 0xce, 0x94, 0x13, 0x5c, 0xd2, 0xf1, 0x40, 0x46, 0x83, 0x38, 0x66,
    0xdd, 0xfd, 0x30, 0xbf, 0x06, 0x8b, 0x62, 0xb3, 0x25, 0xe2, 0x98, 0x22, 0x88, 0x91, 0x10, 0x7e,
    0x6e, 0x48, 0xc3, 0xa3, 0xb6, 0x1e, 0x42, 0x3a, 0x6b, 0x28, 0x54, 0xfa, 0x85, 0x3d, 0xba, 0x2b,
    0x79, 0x0a, 0x15, 0x9b, 0x9f, 0x5e, 0xca, 0x4e, 0xd4, 0xac, 0xe5, 0xf3, 0x73, 0xa7, 0x57, 0xaf,
    0x58, 0xa8, 0x50, 0xf4, 0xea, 0xd6, 0x74, 0x4f, 0xae, 0xe9, 0xd5, 0xe7, 0xe6, 0xad, 0xe8, 0x2c,
    0xd7, 0x75, 0x7a, 0xeb, 0x16, 0x0b, 0xf5, 0x59, 0xcb, 0x5f, 0xb0, 0x9c, 0xa9, 0x51, 0xa0, 0x7f,
    0x0c, 0xf6, 0x6f, 0x17, 0xc4, 0x49, 0xec, 0xd8, 0x43, 0x1f, 0x2d, 0xa4, 0x76, 0x7b, 0xb7, 0xcc,
    0xbb, 0x3e, 0x5a, 0xfb, 0x60, 0xb1, 0x86, 0x3b, 0x52, 0xa1, 0x6c, 0xaa, 0x55, 0x29, 0x9d, 0x97,
    0xb2, 0x87, 0x90, 0x61, 0xbe, 0xdc, 0xfc, 0xbc, 0x95, 0xcf, 0xcd, 0x37, 0x3f, 0x5b, 0xd1, 0x53,
    0x39, 0x84, 0x3c, 0x41, 0xa2, 0x6d, 0x47, 0x14, 0x2a, 0x9e, 0x5d, 0x56, 0xf2, 0xd3, 0xab, 0x44,
    0x11, 0x92, 0xd9, 0x23, 0x20, 0x2e, 0x89, 0xb4, 0x7c, 0xb8, 0x26, 0x77, 0x99, 0xe3, 0xa5, 0x67,
    0x4a, 0xed, 0xde, 0xc5, 0x31, 0xfe, 0x18, 0x0d, 0x63, 0x8c, 0x80, 0xc0, 0xf7, 0x70, 0x07,
];

fn log_lookup(a: u8) -> u8 {
    LOG_TABLE_0X03[a as usize - 1]
}

pub(crate) fn gf256_add(a: u8, b: u8) -> u8 {
    a ^ b
}

pub(crate) fn gf256_sub(a: u8, b: u8) -> u8 {
    gf256_add(a, b)
}

pub(crate) fn gf256_mul(a: u8, b: u8) -> u8 {
    mul_spec(a, b)
}

/// Multiplication from the spec implementation
fn mul_spec(a: u8, b: u8) -> u8 {
    let a = Wrapping(a);
    let b = Wrapping(b);
    let one = Wrapping(1_u8);
    let modulus = Wrapping(MODULUS);
    let mut r: Wrapping<u8> = -(b >> 7) & a;
    r = (-(b >> 6 & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    r = (-(b >> 5 & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    r = (-(b >> 4 & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    r = (-(b >> 3 & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    r = (-(b >> 2 & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    r = (-(b >> 1 & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    r = (-(b & one) & a) ^ (-(r >> 7) & modulus) ^ (r + r);
    return r.0;
}

fn _mul_wiki(a: u8, b: u8) -> u8 {
    // TODO: Lookup carryless multiplication in Rust clmul
    let mut r: u8 = 0;
    let mut a = a.clone();
    let mut b = b.clone();
    while a != 0 && b != 0 {
        if (b & 1) != 0 {
            // f the polynomial for b has a constant term, add the corresponding a to p
            r ^= a // addition in GF(2^m) is an XOR of the polynomial coefficients
        }

        if (a & 0x80) != 0 {
            // If the polynomial for a has a highest term, reduce it modulo the irreducible polynomial
            a = (a << 1) ^ MODULUS; // subtract (XOR) the primitive polynomial â€“
                                    // you can change it but it must be irreducible and %2 == 1
        } else {
            a <<= 1
        }
        b >>= 1
    }

    r
}

/// Multiplication using log table lookup a * b = g^(log_g(a) + log_g(b))
fn _mul_lookup(a: u8, b: u8) -> u8 {
    let log_a = log_lookup(a);
    let log_b = log_lookup(b);
    let res = log_a.wrapping_add(log_b);
    power_lookup(res)
    // TODO: Distributivity of multiplication over addition is not working as expected.
    // Although, not that: However, in cryptographic implementations, one has to be careful with such implementations since the cache architecture of many microprocessors leads to variable timing for memory access. This can lead to implementations that are vulnerable to a timing attack.
}

/// Inverse using log table lookup a^-1 = g^(|g| - log_g(a))
pub(crate) fn gf256_mul_inverse_lookup(a: u8) -> u8 {
    let log_a = log_lookup(a);
    let log_a_inv = ORDER - log_a;
    power_lookup(log_a_inv)
}

pub(crate) fn div(a: u8, b: u8) -> u8 {
    gf256_mul(a, gf256_mul_inverse_lookup(b))
}

#[derive(Clone, Copy)]
struct GF256(u8);

impl Add for GF256 {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        GF256(gf256_add(self.0, rhs.0))
    }
}

impl Sub for GF256 {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        GF256(gf256_sub(self.0, rhs.0))
    }
}

impl Mul for GF256 {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        GF256(gf256_mul(self.0, rhs.0))
    }
}

impl Div for GF256 {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        GF256(div(self.0, rhs.0))
    }
}

impl CheckedDiv for GF256 {
    fn checked_div(&self, rhs: &Self) -> Option<Self> {
        if rhs.0 == 0 {
            return None;
        }
        Some(self.clone() / rhs.clone())
    }
}

impl PartialEq for GF256 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Debug for GF256 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "0x{:02x} ({})", self.0, self.0)
    }
}

// Macro to create a GF256 element
macro_rules! gf256 {
    ($val:expr) => {
        GF256($val)
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{constants::params::PARAM_SEED_SIZE, subroutines::prg::prg::PRG};

    #[test]
    fn test_gf256_definitions() {
        let mut prg = PRG::init(&[2u8; PARAM_SEED_SIZE], None);
        let [a, b, c] = *prg
            .sample_field_elements_gf256(3)
            .iter()
            .map(|x| gf256!(*x))
            .collect::<Vec<GF256>>()
            .as_slice()
        else {
            panic!("Failed to sample 3 field elements");
        };

        // Commutativity of addition and multiplication:
        assert_eq!(a + b, b + a);
        assert_eq!(a * b, b * a);

        // Associativity of addition and multiplication:
        assert_eq!(a + (b + c), (a + b) + c);
        assert_eq!(a * (b * c), (a * b) * c);

        // Identity of addition and multiplication:
        assert_eq!(a + gf256!(0), a);
        assert_eq!(a * gf256!(1), a);

        // Inverse of addition and multiplication:
        assert_eq!(a - a, gf256!(0));
        assert_eq!((a * b) / b, a);

        // Multiplicative identity with additive identity is None:
        assert_eq!(a.checked_div(&gf256!(0)), None);

        // Distributivity of multiplication over addition:
        println!("{:?} {:?} {:?}", a, b, c);
        assert_eq!(a * (b + c), a * b + a * c);
    }
}
