mod utils;
mod witness;
mod xof;
mod keygen;

use crate::{
    constants::{params::PARAM_SEED_SIZE, types::Seed},
    keygen::{PublicKey, SecretKey},
};

pub(self) const SPEC_MASTER_SEED: Seed = [
    124, 153, 53, 160, 176, 118, 148, 170, 12, 109, 16, 228, 219, 107, 26, 221,
];

struct TestVectorResponse {
    count: usize,
    seed: Seed,
    mlen: usize,
    msg: Vec<u8>,
    pk: PublicKey,
    sk: SecretKey,
    sm: Vec<u8>,
    smlen: usize,
}

fn seed_from_hex(hex: &str) -> Seed {
    hex::decode(hex).unwrap()[..PARAM_SEED_SIZE]
        .try_into()
        .unwrap()
}

fn get_value_from_line(line: &str) -> &str {
    line.split(" = ").collect::<Vec<&str>>()[1]
}

// Example from the file
//# sdith_threshold_cat1_gf256
//
//count = 0
//seed = 061550234D158C5EC95595FE04EF7A25767F2E24CC2BC479D09D86DC9ABCFDE7056A8C266F9EF97ED08541DBD2E1FFA1
//mlen = 33
//msg = D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8
//pk = 00C2F93C1571EA14C079BE797D534DB12878B89BCF4CD84....
//sk = 00C2F93C1571EA14C079BE797D534DB12878B89BCF4CD84....
//smlen = 9981
//sm = D8260000D81C4D8D734FCBFBEADE3D3F8A039FAA....
//
//count = 1

/// Read the files generated by the specification library, PQCsignKAT_404.req and PQCsignKAT_404.rsp
fn read_response_test_vectors(n: usize) -> Vec<TestVectorResponse> {
    let rsp_file = include_str!("PQCsignKAT_432.rsp");
    let mut rsp_lines = rsp_file.lines();
    rsp_lines.next(); // Skip the first line -> # sdith_threshold_cat1_gf256

    let mut test_vectors = Vec::new();
    let mut read_vectors = 0;

    while read_vectors < n {
        rsp_lines.next(); // Skip empty line
        let count: usize = get_value_from_line(rsp_lines.next().unwrap())
            .parse()
            .unwrap();
        let seed = seed_from_hex(&get_value_from_line(rsp_lines.next().unwrap()));
        let mlen: usize = get_value_from_line(rsp_lines.next().unwrap())
            .parse()
            .unwrap();

        let msg = hex::decode(get_value_from_line(rsp_lines.next().unwrap())).unwrap();
        let pk = PublicKey::parse_from_hex(&get_value_from_line(rsp_lines.next().unwrap()));
        let sk = SecretKey::parse_from_hex(&get_value_from_line(rsp_lines.next().unwrap()));
        let smlen: usize = get_value_from_line(rsp_lines.next().unwrap())
            .parse()
            .unwrap();
        let sm = hex::decode(get_value_from_line(rsp_lines.next().unwrap())).unwrap();

        test_vectors.push(TestVectorResponse {
            count,
            seed,
            mlen,
            msg,
            pk,
            sk,
            sm,
            smlen,
        });
        read_vectors += 1;
    }

    test_vectors
}

#[cfg(test)]
mod spec_tests {
    use super::*;

    #[test]
    fn test_read_test_vectors() {
        let v = read_response_test_vectors(1);
        assert_eq!(v.len(), 2);
        assert!(v[0].count == 0);
        assert!(v[1].mlen == 66);
        // assert!(v[0].smlen == 9981);
    }
}
