
\documentclass[twoside,11pt,openright]{report}

\usepackage[latin1]{inputenc}
\usepackage[american]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage[fleqn]{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty}
\pagenumbering{roman}
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf SD-in-the-Head rust implementation and optimization}\\[2ex]
{\huge\sf Hugh Benjamin Zachariae, 201508592 \\ Magnus Jensen,
201708626}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Master's Thesis, Computer Science\\[1ex]
  \today \\[1ex] Advisor: Diego F. Aranha\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo{\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Magnus Jensen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

few pages. INtroduce what we have done and how the paper is structured

\todo{motivate and explain the problem to be addressed}

\todo{example of a citation: \cite{DBLP:conf/sas/ChristensenMS03}}
\todo{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Description of the algorithm}
\label{ch:desc}

Abstract level description of the algorithm own words
MPCitH
Syndrome detection problem

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Specification}
\label{ch:spec}
more detailed description of the algorithm
e.g. how we sampled I[e] witness challenge
table of spec params (with our code naming and different categories)

\section{MPC computation}

A toy example of the computation. We have the two computation methods. Here for 1 split and 1 evaluation point. This means that we have only value for each challenge and beaver triple. Note that any arithmetic is run in GF256, so addition and subtraction are both \texttt{XOR} and multiplication is modulus $x^8 + x^4 + x^3 + x + 1$. Furthermore, for negation we have that $-a = a$. \bigskip

\makebox[\textwidth]{
  \fbox{\begin{minipage}[t]{.45\textwidth}
      \noindent \texttt{PartyComputation}
      \begin{flalign*}
         & \textit{Input: }                                                               \\
         & (s_a, Q', P, a, b, c), (\overline{\alpha}, \overline{\beta}), (H', y)          \\
         & (\epsilon, r), \texttt{with\_offset}                                           \\
         & \textit{Output: }                                                              \\
         & (\alpha, \beta, v)                                                             \\\\
         & Q = Q'_1\text{ if \texttt{with\_offset} else }Q'_0                             \\
         & S = (s_a | y + H's_a) \text{ if \texttt{with\_offset} else } (s_a | H's_a)     \\
         & v = -c                                                                         \\
         & \alpha = \epsilon \cdot Q(r) + a                                               \\
         & \beta = S(r) + b                                                               \\
         & v \mathrel{{+}{=}} \epsilon \cdot F(r) \cdot P(r)                              \\
         & v \mathrel{{+}{=}} \overline{\alpha} \cdot b + \overline{\beta} \cdot a        \\
         & c \mathrel{{+}{=}} - \alpha \cdot \beta \text{ \ \ \ if \texttt{with\_offset}}
      \end{flalign*}
    \end{minipage}}
  \hfill
  \noindent
  \fbox{\begin{minipage}[t]{.45\textwidth}
      \noindent \texttt{InverseComputation}
      \begin{flalign*}
         & \textit{Input: }                                                                 \\
         & (s_a, Q', P), (\alpha, \beta, v), (\overline{\alpha}, \overline{\beta}), (H', y) \\
         & (\epsilon, r), \texttt{with\_offset}                                             \\
         & \textit{Output: }                                                                \\
         & (a, b, c)                                                                        \\\\
         & Q = Q_1\text{ if \texttt{with\_offset} else }Q_0                                 \\
         & S = (s_a | y + H's_a) \text{ if \texttt{with\_offset} else } (s_a | H's_a)       \\
         & c = -v                                                                           \\
         & a = \alpha - \epsilon \cdot Q(r)                                                 \\
         & b = \beta - S(r)                                                                 \\
         & c \mathrel{{+}{=}} \epsilon \cdot F(r) \cdot P(r)                                \\
         & c \mathrel{{+}{=}} \overline{\alpha} \cdot b + \overline{\beta} \cdot a          \\
         & c \mathrel{{+}{=}} - \alpha \cdot \beta \text{ \ \ \ if \texttt{with\_offset}}
      \end{flalign*}
    \end{minipage}}}
\bigskip

Note that the $Q_0$ means that $Q$ is completed with a $0$ for leading coefficient. Furthermore, $F$ is precomputed.

If we first instantiate an input $i$ and one random input $i^*$ (like the \texttt{input\_coef}).Then the input share is generated by adding the two. Similar, but simpler, to the input share generation of Algorithm 12, line 13 of the specification.
\begin{align*}
  i             & = (s_a, Q, P, a,b,c)                                             \\
  i^*           & = ({s_a}^*, Q^*, P^*, a^*,b^*,c^*)                               \\
  [i] = i + i^* & = ({s_a} + {s_a}^*, Q + Q^*, P + P^*, a + a^*, b + b^*, c + c^*) \\
                & = ([s_a], [Q], [P], [a], [b], [c])                               \\
  \texttt{chal} & = (\epsilon, r)                                                  \\
  \texttt{pk}   & = (H', y)
\end{align*}

We also compute the plain broadcast share of the input as per Algorithm 12, line 18. $v$ is not computed as it should always be zero.

\begin{align*}
  (\overline{\alpha},\ \overline{\beta}) & =
  \texttt{PartyComputation}(i,\ (0,0),\ \texttt{chal},\ \texttt{pk},\ \texttt{false}) \\
                                         & = (\epsilon \cdot Q_0(r) + a, S_0(r)  + b)
\end{align*}
We then compute a broadcast share from the randomness and the broadcast, as per Algorithm 12, line 21.
\begin{align*}
  (\alpha^*, \beta^*, v^*) & = \texttt{PartyComputation}(i^*, (\overline{\alpha},
  \overline{\beta}), \texttt{chal}, \texttt{pk}, \texttt{false})                  \\\\
  \alpha^*                 & = \epsilon \cdot {[Q]}_0(r) + a^*                    \\
  \beta^*                  & = {[S]}_0(r) + b^*
\end{align*}

This broadcast share is sent to the verifier along with the truncated input share (removing the beaver triples). The verifier then needs to recompute the input share beaver triples using the \texttt{InverseComputation} function. First we add the input share to the broadcast share as per Algorithm 13, line 8.
\begin{align*}
  (\alpha', \beta', v') & = (\alpha^*, \beta^*, v^*) + (\overline{\alpha},\ \overline{\beta}, 0)
  = (\alpha^* + \overline{\alpha}, \beta^* + \overline{\beta}, v^* + 0)                          \\
  \alpha'               & = \epsilon \cdot {[Q]}_0(r) + a^* + \overline{\alpha}                  \\
                        & = \epsilon \cdot {[Q]}_0(r) + a^* + \epsilon \cdot Q_0(r) + a          \\
  \beta'                & = {[S]}_0(r) + b^* + \overline{\beta}                                  \\
                        & = {[S]}_0(r) + b^* + S_0(r) + b                                        \\
\end{align*}

Next, the verifier computes the inverse of the broadcast share to recompute $([a], [b], [c])$ using the \texttt{InverseComputation} function. This is done as per Algorithm 13, line 10.
\begin{align*}
  (a', b', c') & = \texttt{InverseComputation}([i], (\alpha', \beta', v'),
  (\overline{\alpha}, \overline{\beta}), \texttt{chal}, \texttt{pk}, \texttt{true})                        \\
  a'           & = \alpha' - \epsilon \cdot {[Q]}_1(r)                                                     \\
               & = \epsilon \cdot {[Q]}_0(r) + a^* + \epsilon \cdot Q_0(r) + a - \epsilon \cdot {[Q]}_1(r) \\
               & = \epsilon \cdot {[Q]}_0(r) + \epsilon \cdot Q_0(r) - \epsilon \cdot {[Q]}_1(r)   + [a]   \\
  b'           & = \beta' - {[S]}_y(r)                                                                     \\
               & = {[S]}_0(r) + b^* + S_0(r)  + b - {[S]}_y(r)                                             \\
               & = {[S]}_0(r) + S_0(r) - {[S]}_y(r) + [b]
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementation}
\label{ch:impl}

Tooling and language feaures (rust, criterion)
code sections
code re-usability with traits for categories.

const generics vs inline mutability (benchmarking?, nightly?)
traits for categories

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Benchmarks}
\label{ch:bench}
diaries of benchmarks.
discussion of results

\lipsum[1-20] % dummy text

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

wrap up and pose future work
what should people continue with
point to round 2 NIST
work in context of timeline

\todo{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain}
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo{\dots}

\end{document}
